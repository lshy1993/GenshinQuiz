package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"

	"genshin-quiz/internal/models"
	"genshin-quiz/internal/services"
	"genshin-quiz/internal/webserver/middleware/error"
)

// UserHandler implements the OpenAPI generated interface
type UserHandler struct {
	userService *services.UserService
}

func NewUserHandler(userService *services.UserService) *UserHandler {
	return &UserHandler{
		userService: userService,
	}
}

// GetUsers handles GET /api/v1/users
// This method signature can be generated by OpenAPI codegen
func (h *UserHandler) GetUsers(w http.ResponseWriter, r *http.Request) {
	// Parse query parameters
	limitStr := r.URL.Query().Get("limit")
	offsetStr := r.URL.Query().Get("offset")
	search := r.URL.Query().Get("search")

	// Convert and validate parameters
	limit := 10 // default
	if limitStr != "" {
		if parsed, err := strconv.Atoi(limitStr); err == nil && parsed > 0 {
			limit = parsed
		}
	}

	offset := 0 // default
	if offsetStr != "" {
		if parsed, err := strconv.Atoi(offsetStr); err == nil && parsed >= 0 {
			offset = parsed
		}
	}

	// Call service layer
	result, err := h.userService.GetUsers(limit, offset, search)
	if err != nil {
		// Let middleware handle logging, just return appropriate HTTP error
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Failed to retrieve users", "USERS_FETCH_ERROR", err.Error())
		return
	}

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(result)
}

// GetUser handles GET /api/v1/users/{id}
func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	// Extract path parameter
	idStr := chi.URLParam(r, "id")
	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid user ID", "INVALID_USER_ID", "User ID must be a valid number")
		return
	}

	// Call service layer
	user, err := h.userService.GetUser(id)
	if err != nil {
		if err == models.ErrUserNotFound {
			error.WriteErrorResponse(w, http.StatusNotFound, "User not found", "USER_NOT_FOUND", "")
			return
		}
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Failed to retrieve user", "USER_FETCH_ERROR", err.Error())
		return
	}

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(user)
}

// CreateUser handles POST /api/v1/users
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
	var req models.CreateUserRequest

	// Parse request body
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid request body", "INVALID_REQUEST_BODY", err.Error())
		return
	}

	// Call service layer
	user, err := h.userService.CreateUser(req)
	if err != nil {
		// Handle different types of business logic errors
		if err == models.ErrUserAlreadyExists {
			error.WriteErrorResponse(w, http.StatusConflict, "User already exists", "USER_ALREADY_EXISTS", "")
			return
		}
		if err == models.ErrInvalidInput {
			error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid input", "INVALID_INPUT", "")
			return
		}
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Failed to create user", "USER_CREATE_ERROR", err.Error())
		return
	}

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(user)
}

// UpdateUser handles PUT /api/v1/users/{id}
func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request) {
	// Extract path parameter
	idStr := chi.URLParam(r, "id")
	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid user ID", "INVALID_USER_ID", "User ID must be a valid number")
		return
	}

	var req models.UpdateUserRequest

	// Parse request body
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid request body", "INVALID_REQUEST_BODY", err.Error())
		return
	}

	// Call service layer
	user, err := h.userService.UpdateUser(id, req)
	if err != nil {
		if err == models.ErrUserNotFound {
			error.WriteErrorResponse(w, http.StatusNotFound, "User not found", "USER_NOT_FOUND", "")
			return
		}
		if err == models.ErrInvalidInput {
			error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid input", "INVALID_INPUT", "")
			return
		}
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Failed to update user", "USER_UPDATE_ERROR", err.Error())
		return
	}

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(user)
}

// DeleteUser handles DELETE /api/v1/users/{id}
func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) {
	// Extract path parameter
	idStr := chi.URLParam(r, "id")
	id, err := strconv.ParseInt(idStr, 10, 64)
	if err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid user ID", "INVALID_USER_ID", "User ID must be a valid number")
		return
	}

	// Call service layer
	err = h.userService.DeleteUser(id)
	if err != nil {
		if err == models.ErrUserNotFound {
			error.WriteErrorResponse(w, http.StatusNotFound, "User not found", "USER_NOT_FOUND", "")
			return
		}
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Failed to delete user", "USER_DELETE_ERROR", err.Error())
		return
	}

	// Return success response (204 No Content)
	w.WriteHeader(http.StatusNoContent)
}

// Login handles POST /api/v1/auth/login
func (h *UserHandler) Login(w http.ResponseWriter, r *http.Request) {
	var req models.LoginRequest

	// Parse request body
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid request body", "INVALID_REQUEST_BODY", err.Error())
		return
	}

	// Call service layer
	authResp, err := h.userService.Login(req)
	if err != nil {
		if err == models.ErrInvalidCredentials {
			error.WriteErrorResponse(w, http.StatusUnauthorized, "Invalid credentials", "INVALID_CREDENTIALS", "")
			return
		}
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Login failed", "LOGIN_ERROR", err.Error())
		return
	}

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(authResp)
}

// Register handles POST /api/v1/auth/register
func (h *UserHandler) Register(w http.ResponseWriter, r *http.Request) {
	var req models.RegisterRequest

	// Parse request body
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid request body", "INVALID_REQUEST_BODY", err.Error())
		return
	}

	// Call service layer
	authResp, err := h.userService.Register(req)
	if err != nil {
		if err == models.ErrUserAlreadyExists {
			error.WriteErrorResponse(w, http.StatusConflict, "User already exists", "USER_ALREADY_EXISTS", "")
			return
		}
		if err == models.ErrInvalidInput {
			error.WriteErrorResponse(w, http.StatusBadRequest, "Invalid input", "INVALID_INPUT", "")
			return
		}
		error.WriteErrorResponse(w, http.StatusInternalServerError, "Registration failed", "REGISTRATION_ERROR", err.Error())
		return
	}

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(authResp)
}
